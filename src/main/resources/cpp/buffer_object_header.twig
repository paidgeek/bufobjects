{% import "/cpp/types.twig" as tt %}
{%- import "/cpp/macros.twig" as macros -%}
// Generated with https://github.com/paidgeek/bufobjects

#ifndef BUFOBJECTS_BUFFER_OBJECT_H
#define BUFOBJECTS_BUFFER_OBJECT_H

#include <memory>
#include <functional>
#include "buffer_object_builder.h"

namespace bufobjects {

  {% if (utils.rawPointers) %}
    template< typename T, typename S >
    inline T* PointerCast(S* p) {
      return static_cast< T* >(p);
    }
  {% else %}
    template< typename T, typename S >
    inline std::shared_ptr< T > PointerCast(std::shared_ptr< S >& p) {
      return std::dynamic_pointer_cast< T >(p);
    }
  {% endif %}

  class BufferObject {
  public:
  {% if (utils.rawPointers) -%}
    typedef BufferObject* Ptr;
  {%- else -%}
    typedef std::shared_ptr< BufferObject > Ptr;
  {%- endif %}

    BufferObject() {}
    virtual {{ types[bufferObjectIdType] }} BufferObjectId() const = 0;
    virtual void Reset() = 0;
    virtual void CopyTo(BufferObject& dst) const = 0;
    virtual void WriteTo(BufferObjectBuilder& bob) const = 0;
    virtual void ReadFrom(BufferObjectBuilder& bob) = 0;
    virtual uint32_t Size() const = 0;

  };

  {% set enumValues = "" %}
  {% for namespace, definitions in schema -%}
    {%- for definition in definitions -%}
      {%- if(utils.getClassName(definition) == "ClassDefinition") %}
        {% set enumValues = concat(enumValues, trim(macros.getBufferObjectIdName(definition)), " = ", ids[definition], ",\n") %}
      {%- endif -%}
    {%- endfor -%}
  {%- endfor %}
  enum BufferObjectIds : {{ types[bufferObjectIdType] }} {
    {{ enumValues | slice(0, length(enumValues) - 2) }}
  };

  void WriteIdentifiedTo(BufferObjectBuilder& bob, BufferObject::Ptr obj);
  BufferObject::Ptr ReadIdentifiedFrom(BufferObjectBuilder& bob);

}

#endif
